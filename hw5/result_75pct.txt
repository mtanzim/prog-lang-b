eval-exp: comprehensive test with mupl-length function (Not a closure!) [error]
eval-exp: recursive function call (Not a closure!) [error]
ifaunit: first expression is aunit ('(ifaunit (fst (apair (aunit) (int 0))) (int 4) (int 10)) should result in MUPL that evaluates to (int 4) but resulted in (int 10)) [incorrect answer]
ifeq: resulting expression evaluates to e3 if e1 and e2 evaluate to equal integers ('(ifeq (int 5) (int 5) (int 0) (int 1)) should result in MUPL that evaluates to (int 0) but resulted in (mlet "_x" (int 5) (mlet "_y" (int 5) (int 1)))) [incorrect answer]
mupl-map: multiple element list (MUPL fst applied to non-apair) [error]
mupl-map: single element list (MUPL fst applied to non-apair) [error]
mupl-map: empty list (MUPL fst applied to non-apair) [error]
mupl-mapAddN: multiple element list (found bad MUPL expression: "CHANGE (notice map is now in MUPL scope)") [error]
mupl-mapAddN: single element list (found bad MUPL expression: "CHANGE (notice map is now in MUPL scope)") [error]
mupl-mapAddN: empty list (found bad MUPL expression: "CHANGE (notice map is now in MUPL scope)") [error]
compute-free-vars: correctly computes free vars [incorrect answer]
compute-free-vars: no free vars case [incorrect answer]
eval-under-env-c: correctly filters closure environments [incorrect answer]